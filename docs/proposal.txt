Hier überlege ich mir so lange wie das genau funktioniert bis ich genug weiß um anzufangen.

MVC Revisited:

Wo die Geschäftlogik hinkommt wird noch die große Frage...
Es kann mehrere MVCs geben, hier geht es darum wie das glyph/Pfadeditor Problem geschickt gelöst wird.

Das Ziel ist keinen blöden hack zu schreiben, sondern allen code ¡klar definierte!
Aufgaben erfüllen zu lassen, und an den entsprechenden Stellen abzulegen.

Perfomance ist wichtig aber gut aufgeräumt ist wichtiger.




Model:
Hier sind alle Daten gespeichert.
ohne Spekulation heisst das erstmal ein abcGlyph der z.b. vom persistanceLayer (vom Server) gezogen werden kann.

der abcGlyph ist das Element in dem die Pfaddaten manipuliert werden und
hat dazu eine Api, die es z.b. erlaubt einzelne Kontrollpunkte zu verändern.

Die View kann sich (vie Callbacks, als Observer) die Änderungen im Model Angucken
und ist verplichtet(zunächst) diese zu übernehmen. Zeigt also immer die Daten des
Models an. Die View wird über jede Änderung eines Punktes Informiert im moment kann das datenmodell
für reine Pfaddaten einen punkt erstellen, ändern, und löschen. Wobei ändern heißen kann die Koordinate
zu ändern oder metadaten zu ändern (smooth). Koordinaten, auf jeden, aber für die Einhaltung von
Constraints/Abhängigkeiten wie smooth sollte eine andere stelle existieren.

smooth heisst: der radiant zwischen zwei offcurve punkten am gleichen oncurve punkt ist pi
das modell ist mir natürlich etwas zu einfach, wird also erweitert, jedenfalls für die
life-bearbeitung. Auf der persistance ebene geht das wohl nur mit metadaten
(wobei smooth auch schon metadaten ist, hat jedenfalls nichts mit der mathe in den kurven zu tun)

Wer diese Constraints einhält ist noch nicht ganz klar! Ist wohl irgendwo zwischen Controller und Model
gelagert.



Controller:
Verarbeitet Benutzereingaben. Also: Die "Werkzeuge".
Ein Werkzeug selbst hat View-komponenten, nämlich die Kontrollpunkte. Oder auch der Pfad selbst.
Es kommt auf das Werkzeug an, welche dieser Elemente initialisiert werden.

Ein Werkzeug ist dann auch dafür zuständig eventuelle Constraints (wie smooth) zu verwirklichen.
Das Model darf Constraints die es kennt Validieren (also smooth und nur das).

Welche Knoten etc. durch eine Benutzereingabe geändert werden ist Aufgabe des Werkzeuges. Das Werkzeug hat also
selbst auch einen Zustand (State) nämlich z.b. die Auswahl der Knoten die durch eine Benutzereingabe geändert werden.

Das sind Daten Also Model aufgaben. Da unser Model selbst aber zu allgemein ist um die Daten des Werkzeuges zu
speichern, benötigt das Werkzeug selbst einen solchen layer.

Das initialisieren eines Werkzeuges heißt:
Die Kontrollelemente müssen gezeichnet werden.(View) Die Endpunkte (Eventlistener) müssen auf die Kontrollelemente
hören.
Es gibt in diesem Bereich irgendwo die notwendigkeit Die Daten der Eventlistener zu normalisieren.
Das sollte einheitlich und so früh wie möglich geschehen. Denn das Werkzeug soll sich nicht damit befassen
müssen die koordinaten anzugleichen. Dies ist entweder ein Layer zwischen View/Kontrollelement und Controller oder
Teil der View selbst. Möglicherweise kommuniziert gar kein code Ausser der View direkt mit dem DOM oder Umwelt.

So kann diese Logik, die sich mit der unschönen Welt der Browser beschäftigt aus dem eigentlichen Code Rausgehalten werden.
Die Idee ist: nicht einen Filter auf jedes empfangen event anzuwenden, sondern eher jedes event,
durch ein sauberes zu ersetzen und die sauberen events dann weiterzugeben.

function direkter_callback(evt){
    sauberes_event = Sauberes_event(evt);
    for(l in listeners){
        listeners[l](sauberes_event);
    }
}
dabei kann imho dojo helfen!

das ausschalten eines werkzeuges muss ebenso geregelt werden wie das einschalten!
eventhandler müssen entfernt werden, die view muss gereinigt werden... da sollte nichts
übrigbleiben, dammit man schön den speicher und die arbeitsfläche sauberhält.
Das ist wie mini bootstrapping und shutdown!

Um möglichst offen bei den inneren Dingen der MVC Komponenten zu bleiben, sollten sie wirklich über
so kleine schnittstellen wie möglich kommunizieren. Auf der Ebene soll kein DOM spezifischer kram mehr
übrig sein. Nur reine Daten und Zugriffe auf definierte interfaces.

Das Model wird nur vom Controller (Werkzeug) bedient.
Die View beobachtet das Model.
Der Controller bedient das Model.
Der Controller macht mit dem Viewlayer noch etwas für die Kontrollelemente aus


Das Redo/Undo Modell wird vielschichtig...




Wenn ich auf einen Pfad klicke, was genau kann mir das Event berichten?? nur die Koordinaten oder auch
t (zwischen 0 und 1 wobei 0 der Starpunkt ist und 1 der Endpunkt => interessant für sachen wie punkte einfügen, den pfad Teilen)






Das kann natürlich später krass abstrahiert werden, z.b mit spiros. Dann wäre es aber
die Aufgabe der view spiros zu etwas zu konvertieren was sie Anzeigen kann (SVG).

Kontrollpunkte. S





Von einem Ufo glif file befüllt







/**
 *
 * GLyphController:
 *      hält die Daten eines Glyphs und bietet Methoden diese zu ändern.
 *      der controller vermittelt zwischen view und model. er bietet den
 *      kontrollelementen der view die callbackmethoden und kann je nach
 *      datenlage die view-elemente anpassen. Das Arbeitsgedächtnis liegt
 *      hier, alles was nicht gespeichert werden muss liegt hier. Der Rote
 *      faden liegt hier.
 *      Zuordnungen wie von model-koordinate => view-kontrollpunkt liegt in
 *      irgendeeinem dict hier.
 *      der undo/redo code sollte auch hier liegen.
 *
 *
 *
 * GlyphModel
 *      Pfad-Daten:
 *          bestehen im Grunde aus einer liste von Pfad Befehlen
 *          Pfad Befehle bestehen aus Koordinaten.
 *
 *          was am häufigsten geändert wird sind die koordinaten
 *          (durch verschieben der Kontrollpunkte)
 *
 *      Das Ändern der Modeldaten ist Vergleichbar mit einer transaktion
 *      einer Datenbank. Eine Aktion des Users (startdrag) beginnt die
 *      Aufzeichnung. Alle Änderungen am Model werden gesammelt,
 *      (in einer Liste mit Befehlen). Am Ende wird die Transaktion
 *      abgeschlossen "commit" oder verworfen "rollback". Das Model weiß
 *      genug über Pfaddaten um undo / redo machen zu können, und zwar effizient,
 *      wenn nicht anders gewünscht(refresh). Effizient heisst, das Model
 *      ändert nur die daten die geändet wurden, und speichert nicht jedesmal
 *      alle daten, bzw ändert alle daten.
 *
 *      Das Model vergibt -- zur Laufzeit -- einmalige Namen für alle seine Elemente.
 *      so kann kommunikation etc stattfinden, ohne direkt objekte zu übergeben
 *      zugreifen.
 *
 *      model.set(name, wert)
 *
 *      synchron: die view zeigt die daten an, die das model repräsentiert(hält)
 *
 *      normalerweise wird die view immer versuchen Synchron zum Model zu sein
 *      das die view synchron zum model ist, ist aber nicht garantiert. Jeden-
 *      falls nicht zu diesem Zeitpunkt.
 *      Allerdings gibt es Methoden um die View zu aktualisieren. Vielleicht
 *      unterschiedlicher Natur.
 *
 *      Reload: die view wird komplett gelöscht und von den daten des models
 *      neu gebaut -- tabula rasa.
 *
 *      Refresh/Update? nur was geändert wurde wird auch upgedated. Wenn
 *      in der View etwas außerhalb der dem Model bekannten Änderung geschehen
 *      ist, bleibt das unverändert falsch. Dafür sollte dies aber wesentlich
 *      effizienter/schneller sein.
 *
 *
 * GlyphView:
 *      Ist die (Html5 / SVG) Anzeige der Pfad-Daten. Allerdings bietet
 *      sie auch Kontrollelemente, um die Pfaddaten zu ändern.
 *
 *      Ändern der Pfaddaten heisst immer diese im Model zu ändern,
 *      wenn die Daten in der View geändert werden hat dies zunächst keine
 *      Auswirkung auf das Model.
 *
 *      Die view wird von einem controller bedient und sollte möglichst den DOM/SVG
 *      Code vom Rest des Programms trennen.
 *
 */
